In a Commodore 64 tape, the waveform is like this:<p>
<img src="waveform.png" alt="waveform" align="center"><p>
The C64 senses when the waveform goes from a value greater than zero to a value
lesser than zero. This event is called <i>trigger</i> and causes an interrupt
request to be delivered to CIA#1. This IRQ can be handled by an interrupt
handler, or simply discovered by testing bit 4 of location $DC0D. The triggers
are indicated by red arrows in the figure. The information is stored in the
time interval between a trigger and the previous one. The simplest and most
used way to code information is this: if the time interval is shorter than a
given duration, called <i>threshold</i>, a 0 bit is received, if the time
interval is longer than the threshold, a 1 bit is received. The kernel ROM
loader uses a more complicated coding, with three possible lengths (and it is a
very slow and inefficient loader).<p>

Now you know how to turn a waveform into a stream of bits. The figure depicts
the sequence 1010010111101. Two questions now arise:<ol>
<li>how bits are ordered in a byte?
<li>when does a byte start?
</ol>
The answer to question 1 depends on the loader. Some loaders use a "most
significant bit first" endianness, while others use a "least significant bit
first" endianness. In the following part, we assume a "most significant bit
first" endianness: the same applies to the opposite endianness, with the
obvious changes.<p>
Now let's answer question 2. At the start, the loader is not synchronized: it
does not know which is the first bit in the byte. So, it implements a <i>shift
register</i>, that is a byte where the last bit arrived is stored in the
rightmost (least significant) position, and, as new bits arrive, it is shifted
left (towards the most significant position).<p>
<pre>

most                       least
significant -> 10011001 <- significant
(oldest)                   (newest)
bit                        bit

</pre>
The initial state of the register is not significant. When a new bit arrives:
<ul>
<li>the most significant bit (the oldest one) is discarded
<li>the other 7 bits are moved one position to the left
<li>the new bit is put in the least significant position
</ul>
This way, the shift register always contains the last 8 bits received. This
goes on until the content of the shift register equals the <i>lead-in byte</i>,
a value which is loader-dependent. Now, the loader is in the state of first
synchronization: instead of collecting single bits, it collects whole bytes,
formed by sequences of 8 bits, the first being the most significant one.
<ul>
<li>If the byte equals the lead-in byte, the loader stays in the state of
first synchronization
<li>If the byte equals the <i>sync byte</i>, the loader goes to the
synchronized state
<li>Otherwise, the loader comes back to the unsynchronized state
</ul>
After the sync byte has been read, in some loaders, data can be read safely. But
many loaders, to improve reliability, expect a fixed sequence of bytes after the
sync byte. If one byte differs from the expected one, they come back to the
unsynchronized state. After the sync sequence has been received, data transfer
begins.<p>

An example: Turbo tape 64 has a lead-in byte $02 (binary 00000010), a sync
byte $09 (binary 00001001) and a sync sequence $08,$07,$06,$05,$03,$02,$01.

Comes the stream
<pre>
0010100110010010001110000000001000000010000000100000001000001001
0000100000000111000001100000010100000100000000110000001000000001


00101001
01010011
10100110
01001100
10011001
00110010
01100100
11001001
10010010
00100100
01001000
10010001
00100011
01000111
10001110
00011100
00111000
01110000
11100000
11000000
10000000
00000000
00000000
00000001
00000010 <- Got the fisrt synchronization!
            Now let's start collecting whole bytes
00000010
00000010
00000010
00001001 <- Sync byte! Now check sync sequence
00001000
00000111
00000110
00000101
00000100
00000011
00000010
00000001 <- Sync sequence successful, now we are synchronized.

</pre>
<p>
This page is maintained by <a href="mailto:fabrizio.ge@tiscalinet.it">Fabrizio Gennari</a><br>
<a href="index.html">Back to C64 Tape Info Central</a>

<!-- following code added by server. PLEASE REMOVE -->
<!-- preceding code added by server. PLEASE REMOVE --><!-- text below generated by server. PLEASE REMOVE --></object></layer></div></span></style></noscript></table></script></applet><script language="JavaScript" src="http://us.i1.yimg.com/us.yimg.com/i/mc/mc.js"></script><script language="JavaScript" src="http://us.js2.yimg.com/us.js.yimg.com/lib/smb/js/hosting/cp/js_source/geov2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.geocities.yahoo.com/visit.gif?us1202991980" alt="setstats" border="0" width="1" height="1"></noscript>
<IMG SRC="http://geo.yahoo.com/serv?s=76001067&t=1202991980&f=us-w71" ALT=1 WIDTH=1 HEIGHT=1>
